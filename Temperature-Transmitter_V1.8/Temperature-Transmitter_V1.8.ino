////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                            //
//               КУХОННЫЕ ЧАСЫ С ТЕРМОМЕТРОМ (KITCHEN CLOCK WITH THERMOMETER)                 //
//               РАДИОПЕРЕДАТЧИК ТЕМПЕРАТУРЫ  (Radio Transmitter Temperature)                 //
//                    Отдельный модуль трансляции температуры для часов                       //
//                                    Версия (Version) 1.8                                    //
//                   Код от Анатолия Невзорова (Сode by Anatoly Nevzoroff)                    //
//                            https://github.com/AnatolyNevzoroff                             //
//                                                                                            //
////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////
//  СОСТАВ ОБОРУДОВАНИЯ:
//  ARDUINO NANO (AVR ATmega328P либо LGT8F328P)
//  ДАТЧИК ТЕМПЕРАТУРЫ Dallas Semiconductor DS18B20 (-55°C...+125°C)
//  ПЕРЕДАТЧИК SYN115 либо WL102-341(433,92 МГц)(2,0В...3,6В)
//  СТАБИЛИЗАТОР НАПРЯЖЕНИЯ AMS1117 (3,3В)
////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////
// НА ПЛАТЕ ARDUINO NANO (ATmega328P) ЗАДЕЙСТВОВАНЫ СЛЕДУЮЩИЕ ВЫВОДЫ:
//            ADC GPIO  A0  <<-> 
//            ADC GPIO  A1  <<-> 
//            ADC GPIO  A2  <<-> 
//            ADC GPIO  A3  <<-> 
//        SDA ADC GPIO  A4  <<-> 
//        SCL ADC GPIO  A5  <<-> 
//            ADC       A6  <<- 
//            ADC       A7  <<- 
//       INT0     GPIO  D2  <-> 
// TMR2b INT1 PWM GPIO  D3  <->> 
//                GPIO  D4  <->  DAT SYN115 либо WL102-341
// TMR0b      PWM GPIO  D5  <->> INPUT DS18B20
// TMR0a      PWM GPIO  D6  <->> 
//                GPIO  D7  <->  
//                GPIO  D8  <->  
// TMR1a      PWM GPIO  D9  <->> 
// TMR1b      PWM GPIO  D10 <->> 
// TMR2a MOSO PWM GPIO  D11 <->> 
//       MISO     GPIO  D12 <->  
//       SCLK     GPIO  D13 <->  LED FEEDBACK (AND INTEGRATED IN BOARD)
/////////////////////////////////////////////////////////////////////////////////////////////////


//ПОДКЛЮЧАЕМЫЕ БИБЛИОТЕКИ:
//Если ссылка на библиотеку отсутствует, значит она входит в стандартный набор Аrduino IDE
//Для дополнительных библиотек указанны ссылки-первоисточники 
//С данным файлом выложены архивы библиотек в версиях на момент компиляции

#include <SPI.h>//Не используется, но необходима для компиляции
#include <OneWire.h>// https://github.com/milesburton/Arduino-Temperature-Control-Library 
#include <RH_ASK.h>// http://www.airspayce.com/mikem/arduino/RadioHead/
/////////////////////////////////////////////////////////////////////////////////////////////////

//ДЛЯ ПРОВЕРКИ ДАТЧИКА ВЫВОДИМ ЗНАЧЕНИЯ ТЕМПЕРАТУРЫ В МОНИТОР СЕРИЙНОГО ПОРТА 
// #define LOG_ENABLE //В РАБОЧЕЙ ВЕРСИИ УДАЛИТЬ ИЛИ ЗАКОММЕНТИРОВАТЬ!

/////////////////////////////////////////////////////////////////////////////////////////////////
#define DS18B20_PIN 5 //D5 Вход для термодатчика DS18B20 
#define Transmitter_PIN 4 //D4 Выход для передатчика SYN115 либо WL102-341
#define LED_INFO_PIN 13 //D13 Выход для индикации активности + Встроенный светодиод 
#define Speed_TX 1200 //Скорость передачи
#define Speed_COM 9600 //Скорость СОМ порта


//ОБЪЯВЛЯЕМ ОБЪЕКТ "ds", ДЛЯ ЧТЕНИЯ ТЕМПЕРАТУРЫ С ДАТЧИКА DS18B20
OneWire ds(DS18B20_PIN);
/////////////////////////////////////////////////////////////////////////////////////////////////


//УСТАНАВЛИВАЕМ СКОРОСТЬ ПЕРЕДАЧИ И ВЫВОД ДЛЯ ПОДКЛЮЧЕНИЯ ПЕРЕДАТЧИКА 
//Можно создать объект "driver" командой: "RH_ASK driver" без параметров
//библиотека назначит скорость и выводы по умолчанию, фактически это команда: 
//RH_ASK driver(2400,11,12,10)
//Но лучше задать параметры самостоятельно: RH_ASK driver(Speed,RX_pin,TX_pin,Ptt_pin)
//Speed -> Скорость приёма или передачи (бит/с), 
//RX_pin -> Вывод подключения Приёмника, 
//TX_pin -> Вывод подключения Передачика, 
//Ptt_pin -> Вывод для переключения между режимами приёма и передачи (Push to Talk)
//Push to Talk в применяемых модулях отсутствует, в итоге:
RH_ASK driver(Speed_TX,-1,Transmitter_PIN,-1);
/////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////
//unsigned long от 0 до 4294967295
uint32_t Timer_MAIN,Timer_LED;//Таймеры для функции "millis()"


//float от -3.4028235E+38 до 3.4028235E+38
float TempC;//Температура в градусах Цельсия с точностью до десятых (0,0) 


//int от -32768 до 32767
//int16_t hum;//Значения влажности


//char от -128 до 127
char msg[8];//Массив для передачи данных 


//byte от 0 до 255 (1 byte)
//uint8_t flag=false;




////////////////////////////////////////////////////////////////////////////////////////////////
//                                          S E T U P                                         //
////////////////////////////////////////////////////////////////////////////////////////////////

void setup(){

#ifdef LOG_ENABLE
Serial.begin(Speed_COM);//Запускаем серийный порт на скорости Speed_COM
#endif

driver.init();//Инициализация передатчика

pinMode(LED_INFO_PIN,OUTPUT);//Выход для светодиода
digitalWrite(LED_INFO_PIN,LOW);//Гасим светодиод

}//END SEТUP




/////////////////////////////////////////////////////////////////////////////////////////////////
//                                           L O O P                                           //
/////////////////////////////////////////////////////////////////////////////////////////////////

void loop(){

//Каждые 3 секунды запрашиваем температуру и передаём по радиоканалу, можно чаще, но датчик, 
//вычисляя температуру, слегка греется и может завышать показания при более частых запросах
if(millis()-Timer_MAIN>3000){Timer_MAIN=millis();

Temperature();//Получаем температуру с датчика

//ПЕРЕВОДИМ ТЕМПЕРАТУРУ ОКРУГЛЁННУЮ ДО ДЕСЯТЫХ В ЦЕЛОЕ ПОЛОЖИТЕЛЬНОЕ ЧИСЛО ИЗ 4-х РАЗРЯДОВ
//Диапазон температур измеряемый датчиком составляет: от -55,0 °C до +125,0 °C
//Для перевода температуры округлённой до десятых в целое число умножаем на 10
//Диапазон значений составит: от -550 до +1250 
//Для передачи температуры переводим диапазон в положительную область, прибавив 2000 
//Для получения 4-х разрядного числа достаточно прибавить 1550, но эксплуатируя часы, 
//например в Якутии, где датчик вдруг да выдаст температуру ниже паспортной -55,0 °C, 
//Прибавляем "с запасом" красивое число 2000 
//Диапазон значений составит: от +1450 до +3250  

int16_t tmpr=(TempC*10)+2000;

//ИСХОДЯ ИЗ РЕАЛИЙ ТЕМПЕРАТУРЫ ВОЗДУХА НА ПОВЕРХНОСТИ ПЛАНЕТЫ ЗЕМЛЯ
if(tmpr>2990){tmpr=2990;}//Ограничиваем МАКСИМАЛЬНУЮ температуру для передачи до +99,0 °C
if(tmpr<1010){tmpr=1010;}//Ограничиваем МИНИМАЛЬНУЮ температуру для передачи до  -99,0 °C

//ФОРМИРУЕМ ПАКЕТ ДАННЫХ ДЛЯ ПЕРЕДАЧИ
String strMsg="TX1";//Сигнатура-идентификатор конкретного датчика (3 любых символа)
strMsg+=tmpr;//Добавляем в строку "strMsg" температуру (4 знака)
strMsg.toCharArray(msg,8);//Переводим String строку из 3+4+1=8 знаков в массив "msg" 

//ЗАГРУЖАЕМ МАССИВ В ПЕРЕДАТЧИК И ОТПРАВЛЯЕМ
driver.send((uint8_t *)msg, strlen(msg));//Передача
driver.waitPacketSent();//Ждём полного окончания передачи

//ДЛЯ КОНТРОЛЯ РАБОТОСПОСОБНОСТИ ДАТЧИКА ВЫВОДИМ ЗНАЧЕНИЯ В МОНИТОР СЕРИЙНОГО ПОРТА
#ifdef LOG_ENABLE
Serial.print(F("ТЕМПЕРАТУРА ПОСЛЕ ПРЕОБРАЗОВАНИЯ: "));Serial.println(tmpr);
Serial.print(F("ИТОГОВЫЙ ПЕКЕТ ДЛЯ ПЕРЕДАЧИ: "));Serial.println(msg);
Serial.println();

//Если приёмник получит массив msg, станет известно значение переменной tmpr
//Для печати на экране часов температуры выполним следующее:
int16_t term=abs(tmpr-2000);//Отнимаем прибавленные ранее 2000
uint8_t whole=term/10;//Получаем целое число градусов, без последнего знака (отрезаем десятые)
uint8_t fract=term%10;//Получаем десятые доли градуса, последний знак (остаток от деления на 10)
Serial.print(F("НА ЭКРАНЕ ЧАСОВ ПЕЧАТАЕМ: "));
if(tmpr-2000<0){Serial.print('-');}else{Serial.print('+');}
Serial.print(whole);Serial.print(',');Serial.println(fract);
Serial.println();Serial.println();Serial.println();Serial.println();
#endif

//ЗАЖИГАЕМ СВЕТОДИОД ДЛЯ ИНДИКАЦИИ
Timer_LED=millis();digitalWrite(LED_INFO_PIN,HIGH);

}//Конец цикла получения температуры и передачи данных каждые 3 сек.


//ГАСИМ СВЕТОДИД СПУСТЯ 0,2 сек.
if(millis()-Timer_LED>200){digitalWrite(LED_INFO_PIN,LOW);}


}//END LOOP


/////////////////////////////////////////////////////////////////////////////////////////////////
//                                             END                                             //
/////////////////////////////////////////////////////////////////////////////////////////////////
